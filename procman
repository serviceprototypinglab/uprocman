#!/usr/bin/env python3

import sys
import os
import subprocess
import pickle
import time
import signal

class ProcMan:
	def __init__(self):
		self.processes = {}
		self.starttimes = {}

		self.parents = {}
		self.procnames = {}

		self.load()

	def load(self):
		try:
			f = open(".procmandb", "rb")
		except:
			pass
		else:
			[self.processes, self.starttimes] = pickle.load(f)

		self.scanproc()

	def save(self):
		try:
			f = open(".procmandb", "wb")
		except:
			pass
		else:
			pickle.dump([self.processes, self.starttimes], f)

	def scanproc(self):
		procdir = "/proc"
		for subdir in os.listdir(procdir):
			if subdir in ("self",):
				continue
			statusfile = os.path.join(procdir, subdir, "status")
			if os.path.isfile(statusfile):
				f = open(statusfile)
				procname = None
				while True:
					line = f.readline().strip()
					if line.startswith("PPid:"):
						ppid = line.split("\t")[1]
						self.parents[int(subdir)] = int(ppid)
						self.procnames[int(subdir)] = procname
						break
					if line.startswith("Name:"):
						procname = line.split("\t")[1]

	def start(self, argv):
		x = subprocess.Popen(argv)
		self.printline("launched {0} => {1}".format(str(argv), x.pid), True)
		self.processes[x.pid] = argv
		self.starttimes[x.pid] = self.starttime(x.pid)
		self.save()

	def starttime(self, pid):
		try:
			starttime = int(open("/proc/{0}/stat".format(pid)).read().split(" ")[21])
		except:
			starttime = 0
		return starttime

	def stop(self, argv):
		for pid, pargv in self.processes.items():
			if pargv == argv:
				killlist = [pid]
				for cpid in self.parents:
					if self.parents[cpid] == pid:
						killlist.append(cpid)
				self.printline("kill {0}".format(str(killlist)), True)
				for kpid in killlist:
					try:
						os.kill(kpid, signal.SIGTERM)
					except:
						pass
				time.sleep(1)
				for kpid in killlist:
					try:
						os.kill(kpid, signal.SIGKILL)
					except:
						pass
				return
		self.printline("Unknown command, not found.", False)

	def status(self):
		deadlist = []
		for pid in self.processes:
			pgid = self.statuspid(pid)
			if pgid != -1:
				self.printstatus(pid, pgid)
				self.recursepid(pid)
			else:
				deadlist.append(pid)
		for pid in deadlist:
			self.printstatus(pid, -1)
			del self.processes[pid]
		self.save()

	def recursepid(self, pid, indent=0):
			for cpid in self.parents:
				if self.parents[cpid] == pid:
					pgid = self.statuspid(cpid)
					self.printstatus(cpid, pgid, indent + 1)
					self.recursepid(cpid, indent + 1)

	def statuspid(self, pid):
			#alive = os.path.isdir("/proc/{0}".format(pid))
			try:
				pgid = os.getpgid(pid)
			except:
				pgid = -1
			else:
				if pid in self.processes:
					starttime = self.starttime(pid)
					if starttime != self.starttimes[pid]:
						self.printline("(pid cycling for {0})".format(pid), False)
						pgid = -1
			return pgid

	def printstatus(self, pid, pgid, indent=0):
			alive = (pgid != -1)
			if pid in self.starttimes:
				starttime = self.starttimes[pid]
			else:
				starttime = "<unknown>"
			status = "pgid={0} alive={1} start={2}".format(pgid, alive, starttime)
			if pid in self.processes:
				procname = self.processes[pid]
			else:
				if pid in self.procnames:
					procname = "({0})".format(self.procnames[pid])
				else:
					procname = "<unknown>"
			printline = "{3}check {0} => {1}: {2}".format(pid, procname, status, " " * indent)
			self.printline(printline, alive)

	def printline(self, printline, active):
			if active:
				col = "\x1b[32m"
			else:
				col = "\x1b[36m"
			colreset = "\x1b[0m"
			print("{0}{1}{2}".format(col, printline, colreset))

	def parseargs(self):
		if len(sys.argv) >= 2:
			if sys.argv[1] == "start":
				if len(sys.argv) >= 3:
					self.start(sys.argv[2:])
				else:
					return 1
			elif sys.argv[1] == "stop":
				if len(sys.argv) >= 3:
					self.stop(sys.argv[2:])
				else:
					return 1
			elif sys.argv[1] == "status":
				self.status()
			else:
				return 1
		else:
			print("procman start|stop|status <app/unit>")
			return 1

pm = ProcMan()
sys.exit(pm.parseargs())
